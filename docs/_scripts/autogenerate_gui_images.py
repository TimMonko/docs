from pathlib import Path

from qtpy.QtCore import QTimer, QPoint
from napari._qt.qt_event_loop import get_qapp
from napari._qt.qt_resources import get_stylesheet
from napari._qt.dialogs.qt_modal import QtPopup
from qtpy.QtWidgets import QApplication
import napari

DOCS = REPO_ROOT_PATH = Path(__file__).resolve().parent.parent
IMAGES_PATH = DOCS / "images" / "_autogenerated"
IMAGES_PATH.mkdir(parents=True, exist_ok=True)

def autogenerate_images():
    app = get_qapp()
    
    # Create viewer with visible window
    viewer = napari.Viewer(show=True)
    viewer.window._qt_window.resize(800, 600)
    viewer.window._qt_window.setStyleSheet(get_stylesheet("dark"))
    
        # Ensure window is active
    viewer.window._qt_window.activateWindow()
    viewer.window._qt_window.raise_()
    app.processEvents()
    
    viewer.screenshot(str(IMAGES_PATH / "viewer_empty.png"), canvas_only=False)
    # Add sample data
    viewer.open_sample(plugin='napari', sample='cells3d')
    
    app.processEvents() # Ensure viewer is fully initialized
    viewer.screenshot(str(IMAGES_PATH / "viewer_cells3d.png"), canvas_only=False)
    
    # Print Qt widget hierarchy
    # print_widget_hierarchy(viewer.window._qt_window)
    
    # Wait for viewer to fully initialize and render
    QTimer.singleShot(2000, lambda: capture_elements(viewer))
    
    app.exec_()

def capture_elements(viewer):
    """Capture specific UI elements based on the widget hierarchy."""
    
    # Main components - using the hierarchy you provided
    components = {
        "welcome_widget": find_widget_by_class(viewer.window._qt_window, "QtWelcomeWidget"),
        
        "console_dock": find_widget_by_name(viewer.window._qt_window, "console"), # TODO: this was working?
        
        "dimension_slider": find_widget_by_class(viewer.window._qt_window, "QtDims"), #QtDimSliderWidget
        
        # Layer list components
        "layer_list_dock": find_widget_by_name(viewer.window._qt_window, "layer list"),
        "layer_buttons": find_widget_by_class(viewer.window._qt_window, "QtLayerButtons"),
        "layer_list": find_widget_by_class(viewer.window._qt_window, "QtLayerList"),
        "viewer_buttons": find_widget_by_class(viewer.window._qt_window, "QtViewerButtons"),
        
        # Layer controls
        "layer_controls_dock": find_widget_by_name(viewer.window._qt_window, "layer controls"),
       
        # TODO: mouse over part of the image to show intensity stuff
        "status_bar": viewer.window._status_bar,

        # Menus
        "menu_bar": find_widget_by_class(viewer.window._qt_window, "QMenuBar"),
        "file_menu": find_widget_by_name(viewer.window._qt_window, "napari/file"),
        "samples_menu": find_widget_by_name(viewer.window._qt_window, "napari/file/samples/napari"),
        "view_menu": find_widget_by_name(viewer.window._qt_window, "napari/view"),
        "layers_menu": find_widget_by_name(viewer.window._qt_window, "napari/layers"),
        "plugins_menu": find_widget_by_name(viewer.window._qt_window, "napari/plugins"),
        "window_menu": find_widget_by_name(viewer.window._qt_window, "napari/window"),
        "help_menu": find_widget_by_name(viewer.window._qt_window, "napari/help"),
    }
    
    # Capture each component
    for name, widget in components.items():
        try:
            if widget is None:
                print(f"Could not find {name}")
                continue
            
            # For menus, need to show them first
            if name.endswith('_menu'):
                show_menu_for_screenshot(widget, name)
                continue
                
            pixmap = widget.grab()
            pixmap.save(str(IMAGES_PATH / f"{name}.png"))
        except Exception as e:
            print(f"Error capturing {name}: {e}")
    
    QTimer.singleShot(500, lambda: capture_viewer_button_popups(viewer))
    
    # TODO: This needs to be done at the end of capture_elements and not autogenerate_images, why?
    # QTimer.singleShot(100, lambda: close_all(viewer))

def capture_viewer_button_popups(viewer):
    """Capture popups that appear when clicking on viewer buttons."""
    print("Capturing viewer button popups")
    viewer_buttons = find_widget_by_class(viewer.window._qt_window, "QtViewerButtons")
   
    # First capture ndisplay popup, when done it will trigger grid view
    capture_ndisplay_popup(viewer, viewer_buttons)

def capture_ndisplay_popup(viewer, viewer_buttons):
    """Capture the ndisplay button popup."""    
    print("Capturing ndisplay popup")
    
    # Switch to 3D mode to see all perspective controls
    viewer.dims.ndisplay = 3
    get_qapp().processEvents()

    button = viewer_buttons.ndisplayButton
    button.customContextMenuRequested.emit(QPoint())
        
        # Wait longer for the popup to appear
    QTimer.singleShot(800, lambda: find_and_capture_popup("ndisplay_popup", 
                                    lambda: capture_grid_view_popup(viewer, viewer_buttons)))

def capture_grid_view_popup(viewer, viewer_buttons):
    """Capture the grid view button popup."""

    button = viewer_buttons.gridViewButton
    button.customContextMenuRequested.emit(QPoint())
        
    # Wait longer for the popup to appear and then close the app when done
    QTimer.singleShot(800, lambda: find_and_capture_popup("grid_view_popup", 
                                    lambda: QTimer.singleShot(500, lambda: close_all(viewer))))

def find_and_capture_popup(name, next_function=None):
    """Find any open QtPopup widgets and capture them."""
    popup = None
    for widget in QApplication.topLevelWidgets():
        if isinstance(widget, QtPopup):
            popup = widget
            break
    
    if popup:
        try:
            print(f"Found popup, capturing {name}...")
            get_qapp().processEvents()
            
            pixmap = popup.grab()
            pixmap.save(str(IMAGES_PATH / f"{name}.png"))
            popup.close()
            print(f"Captured and closed {name}")
        except Exception as e:
            print(f"Error grabbing popup {name}: {e}")
    else:
        print(f"No popup found for {name}")
    
    # Call the next function in sequence if provided
    if next_function:
        QTimer.singleShot(500, next_function)
    
    
def show_menu_for_screenshot(menu, name):
    """Show a menu and take screenshot of it."""
    menu.popup(menu.parent().mapToGlobal(menu.pos()))
    
    # Give menu time to appear
    def grab_menu():
        pixmap = menu.grab()
        pixmap.save(str(IMAGES_PATH / f"{name}.png"))
        menu.hide()
    
    QTimer.singleShot(300, grab_menu)

def close_all(viewer):
    viewer.close()
    QTimer.singleShot(100, lambda: get_qapp().quit())

def find_widget_by_name(parent, name):
    """Find a widget by its object name."""
    if parent.objectName() == name:
        return parent
        
    for child in parent.children():
        if hasattr(child, 'objectName') and child.objectName() == name:
            return child
        
        if hasattr(child, 'children'):
            found = find_widget_by_name(child, name)
            if found:
                return found
    
    return None

def find_widget_by_class(parent, class_name):
    """Find a child widget by its class name."""
    if parent.__class__.__name__ == class_name:
        return parent
        
    for child in parent.children():
        if child.__class__.__name__ == class_name:
            return child
        
        if hasattr(child, 'children'):
            found = find_widget_by_class(child, class_name)
            if found:
                return found
    
    return None


def print_widget_hierarchy(widget, indent=0, max_depth=None):
    """Print a hierarchy of child widgets with their class names and object names."""

    if max_depth is not None and indent > max_depth:
        return
        
    class_name = widget.__class__.__name__
    object_name = widget.objectName()
    name_str = f" (name: '{object_name}')" if object_name else ""
    print(" " * indent + f"- {class_name}{name_str}")
    
    for child in widget.children():
        if hasattr(child, "children"):
            print_widget_hierarchy(child, indent + 4, max_depth)

    
if __name__ == "__main__":
    autogenerate_images()